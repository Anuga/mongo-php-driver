{
    "docs": [
        {
            "location": "/", 
            "text": "What is pecl/mongodb?\n\n\npecl/mongodb\n is a new MongoDB\ndriver for PHP, which will replace the legacy\n\npecl/mongo\n driver.\n\n\nThis extension is written atop\n\nlibmongoc\n and\n\nlibbson\n, and purposefully offers a basic\nAPI for core functionality (e.g. connection handling, queries, commands, and\nwrite operations). Additional functionality is left to be implemented by\nuserland libraries. Our hope is that this seperation of concerns will keep the\ndriver lightweight (and fast), easier to maintain, and make it an ideal starting\npoint for constructing your own framework, library, or application.\n\n\nInstallation\n\n\nTo build and install the driver:\n\n\n$ pecl install mongodb\n$ echo \nextension=mongodb.so\n \n `php --ini | grep \nLoaded Configuration\n | sed -e \ns|.*:\\s*||\n`\n\n\n\n\nUltimately, this extension is not intended to be used alone. Users should\nconsidering using this driver alongside one or more userland PHP libraries, such\nas \nmongo-php-library\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#what-is-peclmongodb", 
            "text": "pecl/mongodb  is a new MongoDB\ndriver for PHP, which will replace the legacy pecl/mongo  driver.  This extension is written atop libmongoc  and libbson , and purposefully offers a basic\nAPI for core functionality (e.g. connection handling, queries, commands, and\nwrite operations). Additional functionality is left to be implemented by\nuserland libraries. Our hope is that this seperation of concerns will keep the\ndriver lightweight (and fast), easier to maintain, and make it an ideal starting\npoint for constructing your own framework, library, or application.", 
            "title": "What is pecl/mongodb?"
        }, 
        {
            "location": "/#installation", 
            "text": "To build and install the driver:  $ pecl install mongodb\n$ echo  extension=mongodb.so    `php --ini | grep  Loaded Configuration  | sed -e  s|.*:\\s*|| `  Ultimately, this extension is not intended to be used alone. Users should\nconsidering using this driver alongside one or more userland PHP libraries, such\nas  mongo-php-library .", 
            "title": "Installation"
        }, 
        {
            "location": "/crud/", 
            "text": "Basic CRUD Operations\n\n\nSetup and connecting\n\n\n?php\n\n// The document that we'll be working with\n$document = [\nhello\n =\n \nworld\n];\n\n// Construct a write concern\n$wc = new MongoDB\\Driver\\WriteConcern(\n    // Guarantee that writes are acknowledged by a majority of our nodes\n    MongoDB\\Driver\\WriteConcern::MAJORITY,\n    // But only wait 1000ms because we have an application to run!\n    1000\n);\n\n// Construct a read preference\n$rp = new MongoDB\\Driver\\ReadPreference(\n    /* We prefer to read from a secondary, but are OK with reading from the\n     * primary if necessary (e.g. secondaries are offline) */\n    MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED,\n    // Specify some tag sets for our preferred nodes\n    [\n        // Prefer reading from our west coast datacenter in Iceland\n        [\ncountry\n =\n \niceland\n, \ndatacenter\n =\n \nwest\n],\n        // Fall back to any datacenter in Iceland\n        [\ncountry\n =\n \niceland\n],\n        // If Iceland is offline, read from whatever is available\n        [],\n    ]\n);\n\n/* Construct the MongoDB Manager. For brevity, we're only connecting to one node\n * here, but you'd likely want to specify several replica set members in a\n * comma-delimited seed list */\n$manager = new MongoDB\\Driver\\Manager(\nmongodb://localhost:27017\n);\n\n?\n\n\n\n\n\nCreate\n\n\n?php\n\n// Create a bulk write object and add our insert operation\n$bulk = new MongoDB\\Driver\\BulkWrite;\n$bulk-\ninsert($document);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the bulk\n     * write object and an optional write concern. MongoDB\\Driver\\WriteResult is\n     * returned on success; otherwise, an exception is thrown. */\n    $result = $manager-\nexecuteBulkWrite(\ndb.collection\n, $bulk, $wc);\n    var_dump($result);\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n}\n\n?\n\n\n\n\n\nRead\n\n\n?php\n\n/* Construct a query with an empty filter (i.e. \nselect all\n) */\n$query = new MongoDB\\Driver\\Query([]);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the query\n     * object and an optional read preference. MongoDB\\Driver\\Cursor is returned\n     * success; otherwise, an exception is thrown. */\n    $cursor = $manager-\nexecuteQuery(\ndb.collection\n, $query, $rp);\n\n    // Iterate over all matched documents\n    foreach ($cursor as $document) {\n        var_dump($document);\n    }\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n}\n\n?\n\n\n\n\n\nUpdate\n\n\n?php\n\n// Specify the search criteria and update operations (or replacement document)\n$filter = [\nhello\n =\n \nworld\n];\n$newObj = ['$set' =\n [\nhello\n =\n \nwonderful world\n]];\n\n/* Specify some command options for the update:\n *\n *  * multi (boolean): Updates all matching documents when true; otherwise, only\n *    the first matching document is updated. Defaults to false.\n *  * upsert (boolean): If there is no matching document, create a new document\n *    from $filter and $newObj. Defaults to false.\n */\n$options = [\nmulti\n =\n true, \nupsert\n =\n false];\n\n// Create a bulk write object and add our update operation\n$bulk = new MongoDB\\Driver\\BulkWrite;\n$bulk-\nupdate($filter, $newObj, $options);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the bulk\n     * write object and an optional write concern. MongoDB\\Driver\\WriteResult is\n     * returned on success; otherwise, an exception is thrown. */\n    $result = $manager-\nexecuteBulkWrite(\ndb.collection\n, $bulk, $wc);\n    var_dump($result);\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n}\n\n?\n\n\n\n\n\nDelete\n\n\n?php\n\n// Specify the search criteria\n$filter = [\nhello\n =\n \nworld\n];\n\n/* Specify some command options for the update:\n *\n *  * limit (integer): Deletes all matching documents when 0 (false). Otherwise,\n *    only the first matching document is deleted. */\n$options = [\nlimit\n =\n 1];\n\n// Create a bulk write object and add our delete operation\n$bulk = new MongoDB\\Driver\\BulkWrite;\n$bulk-\ndelete($filter, $options);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the bulk\n     * write object and an optional write concern. MongoDB\\Driver\\WriteResult is\n     * returned on success; otherwise, an exception is thrown. */\n    $result = $manager-\nexecuteBulkWrite(\ndb.collection\n, $bulk, $wc);\n    var_dump($result);\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n}\n\n?", 
            "title": "Basic"
        }, 
        {
            "location": "/crud/#basic-crud-operations", 
            "text": "", 
            "title": "Basic CRUD Operations"
        }, 
        {
            "location": "/crud/#setup-and-connecting", 
            "text": "?php\n\n// The document that we'll be working with\n$document = [ hello  =   world ];\n\n// Construct a write concern\n$wc = new MongoDB\\Driver\\WriteConcern(\n    // Guarantee that writes are acknowledged by a majority of our nodes\n    MongoDB\\Driver\\WriteConcern::MAJORITY,\n    // But only wait 1000ms because we have an application to run!\n    1000\n);\n\n// Construct a read preference\n$rp = new MongoDB\\Driver\\ReadPreference(\n    /* We prefer to read from a secondary, but are OK with reading from the\n     * primary if necessary (e.g. secondaries are offline) */\n    MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED,\n    // Specify some tag sets for our preferred nodes\n    [\n        // Prefer reading from our west coast datacenter in Iceland\n        [ country  =   iceland ,  datacenter  =   west ],\n        // Fall back to any datacenter in Iceland\n        [ country  =   iceland ],\n        // If Iceland is offline, read from whatever is available\n        [],\n    ]\n);\n\n/* Construct the MongoDB Manager. For brevity, we're only connecting to one node\n * here, but you'd likely want to specify several replica set members in a\n * comma-delimited seed list */\n$manager = new MongoDB\\Driver\\Manager( mongodb://localhost:27017 );\n\n?", 
            "title": "Setup and connecting"
        }, 
        {
            "location": "/crud/#create", 
            "text": "?php\n\n// Create a bulk write object and add our insert operation\n$bulk = new MongoDB\\Driver\\BulkWrite;\n$bulk- insert($document);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the bulk\n     * write object and an optional write concern. MongoDB\\Driver\\WriteResult is\n     * returned on success; otherwise, an exception is thrown. */\n    $result = $manager- executeBulkWrite( db.collection , $bulk, $wc);\n    var_dump($result);\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e- getMessage(),  \\n ;\n}\n\n?", 
            "title": "Create"
        }, 
        {
            "location": "/crud/#read", 
            "text": "?php\n\n/* Construct a query with an empty filter (i.e.  select all ) */\n$query = new MongoDB\\Driver\\Query([]);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the query\n     * object and an optional read preference. MongoDB\\Driver\\Cursor is returned\n     * success; otherwise, an exception is thrown. */\n    $cursor = $manager- executeQuery( db.collection , $query, $rp);\n\n    // Iterate over all matched documents\n    foreach ($cursor as $document) {\n        var_dump($document);\n    }\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e- getMessage(),  \\n ;\n}\n\n?", 
            "title": "Read"
        }, 
        {
            "location": "/crud/#update", 
            "text": "?php\n\n// Specify the search criteria and update operations (or replacement document)\n$filter = [ hello  =   world ];\n$newObj = ['$set' =  [ hello  =   wonderful world ]];\n\n/* Specify some command options for the update:\n *\n *  * multi (boolean): Updates all matching documents when true; otherwise, only\n *    the first matching document is updated. Defaults to false.\n *  * upsert (boolean): If there is no matching document, create a new document\n *    from $filter and $newObj. Defaults to false.\n */\n$options = [ multi  =  true,  upsert  =  false];\n\n// Create a bulk write object and add our update operation\n$bulk = new MongoDB\\Driver\\BulkWrite;\n$bulk- update($filter, $newObj, $options);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the bulk\n     * write object and an optional write concern. MongoDB\\Driver\\WriteResult is\n     * returned on success; otherwise, an exception is thrown. */\n    $result = $manager- executeBulkWrite( db.collection , $bulk, $wc);\n    var_dump($result);\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e- getMessage(),  \\n ;\n}\n\n?", 
            "title": "Update"
        }, 
        {
            "location": "/crud/#delete", 
            "text": "?php\n\n// Specify the search criteria\n$filter = [ hello  =   world ];\n\n/* Specify some command options for the update:\n *\n *  * limit (integer): Deletes all matching documents when 0 (false). Otherwise,\n *    only the first matching document is deleted. */\n$options = [ limit  =  1];\n\n// Create a bulk write object and add our delete operation\n$bulk = new MongoDB\\Driver\\BulkWrite;\n$bulk- delete($filter, $options);\n\ntry {\n    /* Specify the full namespace as the first argument, followed by the bulk\n     * write object and an optional write concern. MongoDB\\Driver\\WriteResult is\n     * returned on success; otherwise, an exception is thrown. */\n    $result = $manager- executeBulkWrite( db.collection , $bulk, $wc);\n    var_dump($result);\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e- getMessage(),  \\n ;\n}\n\n?", 
            "title": "Delete"
        }, 
        {
            "location": "/bulk/", 
            "text": "Bulk CRUD Operations\n\n\n?php\n\n$hannes = [\n    \nname\n    =\n \nHannes\n,\n    \nnick\n    =\n \nbjori\n,\n    \ncitizen\n =\n \nIceland\n,\n];\n$hayley = [\n    \nname\n    =\n \nBayley\n,\n    \nnick\n    =\n \nAlien Ninja\n,\n    \ncitizen\n =\n \nUSA\n,\n];\n$jonpall = [\n    \nname\n    =\n \nJon Pall\n,\n    \nnick\n    =\n \nunknown\n,\n    \ncitizen\n =\n \nIceland\n,\n];\n\n/* Ordered bulk operations (default) are executed in the same order that we add\n * the write operations. If an operation fails, execution stops and no further\n * operations are attempted. For unordered bulk operations, the operations may\n * be executed in any order by the database in an attempt to optimize its\n * workload. An operation failure within an unordered batch will not stop\n * execution of additional write operations in that batch. */\n$bulk = new MongoDB\\Driver\\BulkWrite(['ordered' =\n true]);\n\n?\n\n\n\n\n\nCreate\n\n\n?php\n\n/* Specify the document to insert (array or object) as the first argument. If a\n * document does not already have an \n_id\n field, a generated\n * MongoDB\\BSON\\ObjectId will be returned. */\n$hannes_id  = $bulk-\ninsert($hannes);\n$hayley_id  = $bulk-\ninsert($hayley);\n$jonpall_id = $bulk-\ninsert($jonpall);\n\n?\n\n\n\n\n\nUpdate\n\n\n?php\n\n/* Arguments:\n *\n *  #1 (array|object): search criteria to select the document(s) for updating\n *  #2 (array|object): replacement document or atomic operations to apply\n *  #3 (array): update options\n *    * multi (boolean): Updates all matching documents when true; otherwise,\n *      only the first matching document is updated. Defaults to false.\n *    * upsert (boolean): If there is no matching document, create a new\n *      document from the first two arguments. Defaults to false.\n */\n$bulk-\nupdate(\n    [\n_id\n =\n $hayley_id],\n    ['$set' =\n [\ncitizen\n =\n \nIceland\n]],\n    [\nmulti\n =\n false, \nupsert\n =\n false]\n);\n$bulk-\nupdate(\n    [\ncitizen\n =\n \nIceland\n],\n    ['$set' =\n [\nviking\n =\n true]],\n    [\nmulti\n =\n true, \nupsert\n =\n false]\n);\n$bulk-\nupdate(\n    [\nname\n =\n \nChuck Norris\n],\n    ['$set' =\n [\nviking\n =\n false]],\n    [\nmulti\n =\n false, \nupsert\n =\n true]\n];\n\n?\n\n\n\n\n\nDelete\n\n\n?php\n\n/* Arguments:\n *\n *  #1 (array|object): search criteria to select the document(s) for deleting\n *  #3 (array): delete options\n *    * limit (integer): Deletes all matching documents when 0 (false).\n *      Otherwise, only the first matching document is deleted. */\n$bulk-\ndelete(\n    [\n_id\n =\n $jonpall_id],\n    [\nlimit\n =\n 1]\n);\n\n?\n\n\n\n\n\nExecuting and checking the results\n\n\n?php\n\n// Construct a write concern\n$wc = new MongoDB\\Driver\\WriteConcern(\n    // Guarantee that writes are acknowledged by a majority of our nodes\n    MongoDB\\Driver\\WriteConcern::MAJORITY,\n    // But only wait 1000ms because we have an application to run!\n    1000\n);\n\n$manager = new MongoDB\\Driver\\Manager(\nmongodb://localhost:27017\n);\n$result  = $manager-\nexecuteBulkWrite(\ndb.collection\n, $bulk, $wc);\n\nprintf(\ninsertedCount: %d\\n\n, $result-\ngetInsertedCount());\nprintf(\nmatchedCount:  %d\\n\n, $result-\ngetMatchedCount());\nprintf(\nmodifiedCount: %d\\n\n, $result-\ngetModifiedCount());\nprintf(\nupsertedCount: %d\\n\n, $result-\ngetUpsertedCount());\nprintf(\ndeletedCount:  %d\\n\n, $result-\ngetDeletedCount());\n\nforeach ($result-\ngetUpsertedIds() as $index =\n $id) {\n    printf(\nupsertedId: '%s', index: %d\\n\n, $id, $index);\n}\n\n$query  = new MongoDB\\Driver\\Query([\nviking\n =\n false]);\n$cursor = $manager-\nexecuteQuery(\ndb.collection\n, $query);\n\n/* Note that var_dump()-ing the $cursor directly will print out additional debug\n * information about the cursor, such as the read preferenced used, the query\n * executed, namespace, query flags, and information about the current batch of\n * results from the server. Instead, we'll simply var_dump() the results. */\nvar_dump($cursor-\ntoArray());\n\n?", 
            "title": "Bulks"
        }, 
        {
            "location": "/bulk/#bulk-crud-operations", 
            "text": "?php\n\n$hannes = [\n     name     =   Hannes ,\n     nick     =   bjori ,\n     citizen  =   Iceland ,\n];\n$hayley = [\n     name     =   Bayley ,\n     nick     =   Alien Ninja ,\n     citizen  =   USA ,\n];\n$jonpall = [\n     name     =   Jon Pall ,\n     nick     =   unknown ,\n     citizen  =   Iceland ,\n];\n\n/* Ordered bulk operations (default) are executed in the same order that we add\n * the write operations. If an operation fails, execution stops and no further\n * operations are attempted. For unordered bulk operations, the operations may\n * be executed in any order by the database in an attempt to optimize its\n * workload. An operation failure within an unordered batch will not stop\n * execution of additional write operations in that batch. */\n$bulk = new MongoDB\\Driver\\BulkWrite(['ordered' =  true]);\n\n?", 
            "title": "Bulk CRUD Operations"
        }, 
        {
            "location": "/bulk/#create", 
            "text": "?php\n\n/* Specify the document to insert (array or object) as the first argument. If a\n * document does not already have an  _id  field, a generated\n * MongoDB\\BSON\\ObjectId will be returned. */\n$hannes_id  = $bulk- insert($hannes);\n$hayley_id  = $bulk- insert($hayley);\n$jonpall_id = $bulk- insert($jonpall);\n\n?", 
            "title": "Create"
        }, 
        {
            "location": "/bulk/#update", 
            "text": "?php\n\n/* Arguments:\n *\n *  #1 (array|object): search criteria to select the document(s) for updating\n *  #2 (array|object): replacement document or atomic operations to apply\n *  #3 (array): update options\n *    * multi (boolean): Updates all matching documents when true; otherwise,\n *      only the first matching document is updated. Defaults to false.\n *    * upsert (boolean): If there is no matching document, create a new\n *      document from the first two arguments. Defaults to false.\n */\n$bulk- update(\n    [ _id  =  $hayley_id],\n    ['$set' =  [ citizen  =   Iceland ]],\n    [ multi  =  false,  upsert  =  false]\n);\n$bulk- update(\n    [ citizen  =   Iceland ],\n    ['$set' =  [ viking  =  true]],\n    [ multi  =  true,  upsert  =  false]\n);\n$bulk- update(\n    [ name  =   Chuck Norris ],\n    ['$set' =  [ viking  =  false]],\n    [ multi  =  false,  upsert  =  true]\n];\n\n?", 
            "title": "Update"
        }, 
        {
            "location": "/bulk/#delete", 
            "text": "?php\n\n/* Arguments:\n *\n *  #1 (array|object): search criteria to select the document(s) for deleting\n *  #3 (array): delete options\n *    * limit (integer): Deletes all matching documents when 0 (false).\n *      Otherwise, only the first matching document is deleted. */\n$bulk- delete(\n    [ _id  =  $jonpall_id],\n    [ limit  =  1]\n);\n\n?", 
            "title": "Delete"
        }, 
        {
            "location": "/bulk/#executing-and-checking-the-results", 
            "text": "?php\n\n// Construct a write concern\n$wc = new MongoDB\\Driver\\WriteConcern(\n    // Guarantee that writes are acknowledged by a majority of our nodes\n    MongoDB\\Driver\\WriteConcern::MAJORITY,\n    // But only wait 1000ms because we have an application to run!\n    1000\n);\n\n$manager = new MongoDB\\Driver\\Manager( mongodb://localhost:27017 );\n$result  = $manager- executeBulkWrite( db.collection , $bulk, $wc);\n\nprintf( insertedCount: %d\\n , $result- getInsertedCount());\nprintf( matchedCount:  %d\\n , $result- getMatchedCount());\nprintf( modifiedCount: %d\\n , $result- getModifiedCount());\nprintf( upsertedCount: %d\\n , $result- getUpsertedCount());\nprintf( deletedCount:  %d\\n , $result- getDeletedCount());\n\nforeach ($result- getUpsertedIds() as $index =  $id) {\n    printf( upsertedId: '%s', index: %d\\n , $id, $index);\n}\n\n$query  = new MongoDB\\Driver\\Query([ viking  =  false]);\n$cursor = $manager- executeQuery( db.collection , $query);\n\n/* Note that var_dump()-ing the $cursor directly will print out additional debug\n * information about the cursor, such as the read preferenced used, the query\n * executed, namespace, query flags, and information about the current batch of\n * results from the server. Instead, we'll simply var_dump() the results. */\nvar_dump($cursor- toArray());\n\n?", 
            "title": "Executing and checking the results"
        }, 
        {
            "location": "/commands/", 
            "text": "Executing Commands\n\n\nListing databases and collections\n\n\n?php\n\n// Construct the MongoDB Manager\n$manager = new MongoDB\\Driver\\Manager(\nmongodb://localhost:27017\n);\n\n// Construct and execute the listDatabases command\n$listdatabases = new MongoDB\\Driver\\Command([\nlistDatabases\n =\n 1]);\n$result        = $manager-\nexecuteCommand(\nadmin\n, $listdatabases);\n\n/* The command returns a single result document, which contains the information\n * for all databases in a \ndatabases\n array field. */\n$databases     = current($result-\ntoArray());\n\nforeach ($databases[\ndatabases\n] as $database) {\n    echo $database-\nname, \n\\n\n;\n\n    // Construct and execute the listCollections command for each database\n    $listcollections = new MongoDB\\Driver\\Command([\nlistCollections\n =\n 1]);\n    $result          = $manager-\nexecuteCommand($database-\nname, $listcollections);\n\n    /* The command returns a cursor, which we can iterate on to access\n     * information for each collection. */\n    $collections     = $result-\ntoArray();\n\n    foreach ($collections as $collection) {\n        echo \n\\t * \n, $collection-\nname, \n\\n\n;\n    }\n}\n\n?\n\n\n\n\n\nCreate a user\n\n\n?php\n\n// Construct the MongoDB Manager\n$manager = new MongoDB\\Driver\\Manager(\nmongodb://localhost:27017\n);\n\n// Construct the createUser command\n$createuser = new MongoDB\\Driver\\Command([\n    \ncreateUser\n =\n \nUSERNAME2\n,\n    \npwd\n        =\n \nPASSWORD\n,\n    \nroles\n      =\n [\n        [\nrole\n =\n \nclusterAdmin\n,         \ndb\n =\n \nadmin\n],\n        [\nrole\n =\n \nreadWriteAnyDatabase\n, \ndb\n =\n \nadmin\n],\n        [\nrole\n =\n \nuserAdminAnyDatabase\n, \ndb\n =\n \nadmin\n],\n        \nreadWrite\n,\n    ],\n    \nwriteConcern\n =\n [\nw\n =\n \nmajority\n],\n]);\n\ntry {\n    $result     = $manager-\nexecuteCommand(\nadmin\n, $createuser);\n    $response   = current($result-\ntoArray());\n\n    if ($response[\nok\n]) {\n        echo \nUser created successfully\\n\n;\n    }\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n}\n\n?\n\n\n\n\n\nCommands and read preferences\n\n\n?php\n\n/* Some commands (e.g. count, aggregate) may be executed on secondaries. As with\n * normal queries, we can supply a MongoDB\\Driver\\ReadPreference object when\n * executing a command in order to prefer certain servers over others. */\n\n// Construct a read preference\n$rp = new MongoDB\\Driver\\ReadPreference(\n    /* We prefer to read from a secondary, but are OK with reading from the\n     * primary if necessary (e.g. secondaries are offline) */\n    MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED,\n    // Specify some tag sets for our preferred nodes\n    [\n        // Prefer reading from our west coast datacenter in Iceland\n        [\ncountry\n =\n \niceland\n, \ndatacenter\n =\n \nwest\n],\n        // Fall back to any datacenter in Iceland\n        [\ncountry\n =\n \niceland\n],\n        // If Iceland is offline, read from whatever is available\n        [],\n    ]\n);\n\n// Construct the MongoDB Manager\n$manager = new MongoDB\\Driver\\Manager(\nmongodb://localhost:27017\n);\n\n$query = [\ncitizen\n =\n \nIceland\n];\n$count = new MongoDB\\Driver\\Command([\ncount\n =\n \ncollection\n, \nquery\n =\n $query]);\n\ntry {\n    $result   = $manager-\nexecuteCommand(\ndb\n, $count, $rp);\n    $response = current($result-\ntoArray());\n\n    if ($response[\nok\n]) {\n        printf(\ndb.collection has %d document(s) matching: %s\\n\n,\n            $response[\nn\n],\n            MongoDB\\BSON\\toJSON(MongoDB\\BSON\\fromArray($query))\n        );\n    }\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n}\n\n?", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#executing-commands", 
            "text": "", 
            "title": "Executing Commands"
        }, 
        {
            "location": "/commands/#listing-databases-and-collections", 
            "text": "?php\n\n// Construct the MongoDB Manager\n$manager = new MongoDB\\Driver\\Manager( mongodb://localhost:27017 );\n\n// Construct and execute the listDatabases command\n$listdatabases = new MongoDB\\Driver\\Command([ listDatabases  =  1]);\n$result        = $manager- executeCommand( admin , $listdatabases);\n\n/* The command returns a single result document, which contains the information\n * for all databases in a  databases  array field. */\n$databases     = current($result- toArray());\n\nforeach ($databases[ databases ] as $database) {\n    echo $database- name,  \\n ;\n\n    // Construct and execute the listCollections command for each database\n    $listcollections = new MongoDB\\Driver\\Command([ listCollections  =  1]);\n    $result          = $manager- executeCommand($database- name, $listcollections);\n\n    /* The command returns a cursor, which we can iterate on to access\n     * information for each collection. */\n    $collections     = $result- toArray();\n\n    foreach ($collections as $collection) {\n        echo  \\t *  , $collection- name,  \\n ;\n    }\n}\n\n?", 
            "title": "Listing databases and collections"
        }, 
        {
            "location": "/commands/#create-a-user", 
            "text": "?php\n\n// Construct the MongoDB Manager\n$manager = new MongoDB\\Driver\\Manager( mongodb://localhost:27017 );\n\n// Construct the createUser command\n$createuser = new MongoDB\\Driver\\Command([\n     createUser  =   USERNAME2 ,\n     pwd         =   PASSWORD ,\n     roles       =  [\n        [ role  =   clusterAdmin ,          db  =   admin ],\n        [ role  =   readWriteAnyDatabase ,  db  =   admin ],\n        [ role  =   userAdminAnyDatabase ,  db  =   admin ],\n         readWrite ,\n    ],\n     writeConcern  =  [ w  =   majority ],\n]);\n\ntry {\n    $result     = $manager- executeCommand( admin , $createuser);\n    $response   = current($result- toArray());\n\n    if ($response[ ok ]) {\n        echo  User created successfully\\n ;\n    }\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e- getMessage(),  \\n ;\n}\n\n?", 
            "title": "Create a user"
        }, 
        {
            "location": "/commands/#commands-and-read-preferences", 
            "text": "?php\n\n/* Some commands (e.g. count, aggregate) may be executed on secondaries. As with\n * normal queries, we can supply a MongoDB\\Driver\\ReadPreference object when\n * executing a command in order to prefer certain servers over others. */\n\n// Construct a read preference\n$rp = new MongoDB\\Driver\\ReadPreference(\n    /* We prefer to read from a secondary, but are OK with reading from the\n     * primary if necessary (e.g. secondaries are offline) */\n    MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED,\n    // Specify some tag sets for our preferred nodes\n    [\n        // Prefer reading from our west coast datacenter in Iceland\n        [ country  =   iceland ,  datacenter  =   west ],\n        // Fall back to any datacenter in Iceland\n        [ country  =   iceland ],\n        // If Iceland is offline, read from whatever is available\n        [],\n    ]\n);\n\n// Construct the MongoDB Manager\n$manager = new MongoDB\\Driver\\Manager( mongodb://localhost:27017 );\n\n$query = [ citizen  =   Iceland ];\n$count = new MongoDB\\Driver\\Command([ count  =   collection ,  query  =  $query]);\n\ntry {\n    $result   = $manager- executeCommand( db , $count, $rp);\n    $response = current($result- toArray());\n\n    if ($response[ ok ]) {\n        printf( db.collection has %d document(s) matching: %s\\n ,\n            $response[ n ],\n            MongoDB\\BSON\\toJSON(MongoDB\\BSON\\fromArray($query))\n        );\n    }\n} catch (MongoDB\\Driver\\Exception\\Exception $e) {\n    echo $e- getMessage(),  \\n ;\n}\n\n?", 
            "title": "Commands and read preferences"
        }, 
        {
            "location": "/ods/", 
            "text": "Object serialization\n\n\nThis driver includes four public interfaces to facilitate serializing PHP\nclasses to and from BSON.\n\n\n\n\nMongoDB\\BSON\\Type\n\n\n(no methods)\n\n\n\n\n\n\nMongoDB\\BSON\\Serializable\n\n\nabstract public method bsonSerialize();\n\n\n\n\n\n\nMongoDB\\BSON\\Unserializable\n\n\nabstract public method bsonUnserialize(array $data);\n\n\n\n\n\n\nMongoDB\\BSON\\Persistable\n\n\nextends both BSON\\Serializable and BSON\\Unserializable\n\n\n\n\n\n\n\n\nObjects that implement the MongoDB\\BSON\\Type interface get special treatment by\nthe BSON serializer. In general, these objects represent a BSON type that cannot\nbe natively represented in PHP (e.g. MongoDB\\BSON\\UTCDatetime,\nMongoDB\\BSON\\ObjectID) and are explicitly checked for and handled by the driver.\nMongoDB\\BSON\\Type should not be implemented directly by userland classes.\n\n\nUserland classes that require custom BSON serialization should utilize the\nMongoDB\\BSON\\Serializable interface and implement the \nbsonSerialize()\n\nfunction, which should return a document (i.e. PHP array or stdClass object)\nrepresenting the document that should be stored. Furthermore, if the object\nimplements the MongoDB\\BSON\\Persistable interface, the driver will also inject a\nMongoDB\\BSON\\Binary value (with type 0x80 and an internal field name) into the\ndocument, which contains the userland object's fully qualified classname. This\nfield can then be used during unserialization to ensure that the BSON document\nbecomes an object of the same class on the way out of the database.\n\n\nDuring unserialization of a document, if a BSON Binary value (with type 0x80 and\nwithin the expected internal field name) is encountered, the driver will peek at\nthe value and attempt to resolve it to a classname (triggering autoloaders if\nneccesary). If the class name cannot be resolved, nothing magical happens;\nhowever, if the class exists, the driver will create a new instance (without\ninvoking the constructor) and invoke its \nbsonUnserialize()\n method, supplying\nthe unserialized document data as a PHP array. Note that this happens\ndepth-first, which means that embedded documents will be resolved before their\nparent.\n\n\nExamples\n\n\nConsider the following two classes: Person and Address. A Person has name, age,\nfriends (array of Person objects), and addresses (array of Address objects). A\nPerson also has a secret, that we would rather not store in a database.\n\n\n?php\n\nclass Person implements MongoDB\\BSON\\Persistable\n{\n    protected $_id;\n    protected $name;\n    protected $age;\n    protected $address = [];\n    protected $friends = [];\n    protected $secret = \nnone\n;\n\n    function __construct($name, $age)\n    {\n        $this-\nname    = $name;\n        $this-\nage     = $age;\n        $this-\naddress = [];\n        $this-\nsecret  = \n$name confidential info\n;\n        /* Pregenerate our ObjectID */\n        $this-\n_id     = new MongoDB\\BSON\\ObjectID();\n    }\n\n    function addAddress(Address $address)\n    {\n        $this-\naddress[] = $address;\n    }\n\n    function addFriend(Person $friend)\n    {\n        $this-\nfriends[] = $friend;\n    }\n\n    function bsonSerialize()\n    {\n        return [\n            \n_id\n     =\n $this-\n_id,\n            \nname\n    =\n $this-\nname,\n            \nage\n     =\n $this-\nage,\n            \naddress\n =\n $this-\naddress,\n            \nfriends\n =\n $this-\nfriends,\n        ];\n    }\n\n    function bsonUnserialize(array $data)\n    {\n        $this-\n_id     = $data[\n_id\n];\n        $this-\nname    = $data[\nname\n];\n        $this-\nage     = $data[\nage\n];\n        $this-\naddress = $data[\naddress\n];\n        $this-\nfriends = $data[\nfriends\n];\n    }\n}\n\nclass Address implements MongoDB\\BSON\\Persistable\n{\n    protected $zip;\n    protected $country;\n\n    function __construct($zip, $country)\n    {\n        $this-\nzip = $zip;\n        $this-\ncountry = $country;\n    }\n\n    function bsonSerialize()\n    {\n        return [\n            \nzip\n     =\n $this-\nzip,\n            \ncountry\n =\n $this-\ncountry,\n        ];\n    }\n\n    function bsonUnserialize(array $data)\n    {\n        $this-\nzip = $data[\nzip\n];\n        $this-\ncountry = $data[\ncountry\n];\n    }\n}\n\n?\n\n\n\n\n\nHannes is 31 years old and has two addresses;\n\n\n\n\nSunnyvale, USA\n\n\nKopavogur, Iceland\n\n\n\n\nHe is friends with young Jeremy, a 21 year old who lives in Michigan:\n\n\n?php\n$hannes = new Person(\nHannes\n, 31);\n$sunnyvale = new Address(94086, \nUSA\n);\n$kopavogur = new Address(200, \nIceland\n);\n$hannes-\naddAddress($sunnyvale);\n$hannes-\naddAddress($kopavogur);\n\n$mikola = new Person(\nJeremy\n, 21);\n$michigan = new Address(48169, \nUSA\n);\n$mikola-\naddAddress($michigan);\n\n$hannes-\naddFriend($mikola);\n\n?\n\n\n\n\n\nTo save this information, we can insert \n$hannes\n into the database like so:\n\n\n?php\ntry {\n    $wc = new MongoDB\\Driver\\WriteConcern(MongoDB\\Driver\\WriteConcern::MAJORITY);\n    $manager = new MongoDB\\Driver\\Manager(\nmongodb://192.168.112.10:2000\n);\n    $bulk = new MongoDB\\Driver\\BulkWrite;\n    $bulk-\ninsert($hannes);\n    $result = $manager-\nexecuteBulkWrite(\ncongress.people\n, $bulk, $wc);\n    echo \nHannes has been inserted\\n\n;\n} catch(Exception $e) {\n    echo $e-\ngetMessage(), \n\\n\n;\n    exit;\n}\n?\n\n\n\n\n\nThis will result in the following document stored (as shown by mongo shell):\n\n\n{\n  \n_id\n : ObjectId(\n551f2004bd21b959de3c15b1\n),\n  \n__pclass\n : BinData(128,\nUGVyc29u\n),\n  \nname\n : \nHannes\n,\n  \nage\n : 31,\n  \naddress\n : [\n    {\n      \n__pclass\n : BinData(128,\nQWRkcmVzcw==\n),\n      \nzip\n : 94086,\n      \ncountry\n : \nUSA\n\n    },\n    {\n      \n__pclass\n : BinData(128,\nQWRkcmVzcw==\n),\n      \nzip\n : 200,\n      \ncountry\n : \nIceland\n\n    }\n  ],\n  \nfriends\n : [\n    {\n      \n__pclass\n : BinData(128,\nUGVyc29u\n),\n      \n_id\n : ObjectId(\n551f2004bd21b959de3c15b2\n),\n      \nname\n : \nJeremy\n,\n      \nage\n : 21,\n      \naddress\n : [\n        {\n          \n__pclass\n : BinData(128,\nQWRkcmVzcw==\n),\n          \nzip\n : 48169,\n          \ncountry\n : \nUSA\n\n        }\n      ],\n      \nfriends\n : {\n\n      }\n    }\n  ]\n}\n\n\n\n\nWhen we read this document back, the driver will convert the individual\nsub-documents back into their original classes, as we have full type information\nfor them now:\n\n\n?php\n\n$rp = new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_PRIMARY_PREFERRED);\n$query = new MongoDB\\Driver\\Query([]);\n$cursor = $manager-\nexecuteQuery(\ncongress.people\n, $query, $rp);\n\nforeach($cursor as $person) {\n    var_dump($person);\n}\n\n?\n\n\n\n\n\nThis results in:\n\n\nobject(Person)#22 (6) {\n  [\n_id\n:protected]=\n\n  object(BSON\\ObjectID)#15 (0) {\n  }\n  [\nname\n:protected]=\n\n  string(6) \nHannes\n\n  [\nage\n:protected]=\n\n  int(31)\n  [\naddress\n:protected]=\n\n  array(2) {\n    [0]=\n\n    object(Address)#16 (2) {\n      [\nzip\n:protected]=\n\n      int(94086)\n      [\ncountry\n:protected]=\n\n      string(3) \nUSA\n\n    }\n    [1]=\n\n    object(Address)#17 (2) {\n      [\nzip\n:protected]=\n\n      int(200)\n      [\ncountry\n:protected]=\n\n      string(7) \nIceland\n\n    }\n  }\n  [\nfriends\n:protected]=\n\n  array(1) {\n    [0]=\n\n    object(Person)#21 (6) {\n      [\n_id\n:protected]=\n\n      object(BSON\\ObjectID)#18 (0) {\n      }\n      [\nname\n:protected]=\n\n      string(6) \nJeremy\n\n      [\nage\n:protected]=\n\n      int(21)\n      [\naddress\n:protected]=\n\n      array(1) {\n        [0]=\n\n        object(Address)#19 (2) {\n          [\nzip\n:protected]=\n\n          int(48169)\n          [\ncountry\n:protected]=\n\n          string(3) \nUSA\n\n        }\n      }\n      [\nfriends\n:protected]=\n\n      object(stdClass)#20 (0) {\n      }\n      [\nsecret\n:protected]=\n\n      string(4) \nnone\n\n    }\n  }\n  [\nsecret\n:protected]=\n\n  string(4) \nnone\n\n}", 
            "title": "Object Document Serialization"
        }, 
        {
            "location": "/ods/#object-serialization", 
            "text": "This driver includes four public interfaces to facilitate serializing PHP\nclasses to and from BSON.   MongoDB\\BSON\\Type  (no methods)    MongoDB\\BSON\\Serializable  abstract public method bsonSerialize();    MongoDB\\BSON\\Unserializable  abstract public method bsonUnserialize(array $data);    MongoDB\\BSON\\Persistable  extends both BSON\\Serializable and BSON\\Unserializable     Objects that implement the MongoDB\\BSON\\Type interface get special treatment by\nthe BSON serializer. In general, these objects represent a BSON type that cannot\nbe natively represented in PHP (e.g. MongoDB\\BSON\\UTCDatetime,\nMongoDB\\BSON\\ObjectID) and are explicitly checked for and handled by the driver.\nMongoDB\\BSON\\Type should not be implemented directly by userland classes.  Userland classes that require custom BSON serialization should utilize the\nMongoDB\\BSON\\Serializable interface and implement the  bsonSerialize() \nfunction, which should return a document (i.e. PHP array or stdClass object)\nrepresenting the document that should be stored. Furthermore, if the object\nimplements the MongoDB\\BSON\\Persistable interface, the driver will also inject a\nMongoDB\\BSON\\Binary value (with type 0x80 and an internal field name) into the\ndocument, which contains the userland object's fully qualified classname. This\nfield can then be used during unserialization to ensure that the BSON document\nbecomes an object of the same class on the way out of the database.  During unserialization of a document, if a BSON Binary value (with type 0x80 and\nwithin the expected internal field name) is encountered, the driver will peek at\nthe value and attempt to resolve it to a classname (triggering autoloaders if\nneccesary). If the class name cannot be resolved, nothing magical happens;\nhowever, if the class exists, the driver will create a new instance (without\ninvoking the constructor) and invoke its  bsonUnserialize()  method, supplying\nthe unserialized document data as a PHP array. Note that this happens\ndepth-first, which means that embedded documents will be resolved before their\nparent.", 
            "title": "Object serialization"
        }, 
        {
            "location": "/ods/#examples", 
            "text": "Consider the following two classes: Person and Address. A Person has name, age,\nfriends (array of Person objects), and addresses (array of Address objects). A\nPerson also has a secret, that we would rather not store in a database.  ?php\n\nclass Person implements MongoDB\\BSON\\Persistable\n{\n    protected $_id;\n    protected $name;\n    protected $age;\n    protected $address = [];\n    protected $friends = [];\n    protected $secret =  none ;\n\n    function __construct($name, $age)\n    {\n        $this- name    = $name;\n        $this- age     = $age;\n        $this- address = [];\n        $this- secret  =  $name confidential info ;\n        /* Pregenerate our ObjectID */\n        $this- _id     = new MongoDB\\BSON\\ObjectID();\n    }\n\n    function addAddress(Address $address)\n    {\n        $this- address[] = $address;\n    }\n\n    function addFriend(Person $friend)\n    {\n        $this- friends[] = $friend;\n    }\n\n    function bsonSerialize()\n    {\n        return [\n             _id      =  $this- _id,\n             name     =  $this- name,\n             age      =  $this- age,\n             address  =  $this- address,\n             friends  =  $this- friends,\n        ];\n    }\n\n    function bsonUnserialize(array $data)\n    {\n        $this- _id     = $data[ _id ];\n        $this- name    = $data[ name ];\n        $this- age     = $data[ age ];\n        $this- address = $data[ address ];\n        $this- friends = $data[ friends ];\n    }\n}\n\nclass Address implements MongoDB\\BSON\\Persistable\n{\n    protected $zip;\n    protected $country;\n\n    function __construct($zip, $country)\n    {\n        $this- zip = $zip;\n        $this- country = $country;\n    }\n\n    function bsonSerialize()\n    {\n        return [\n             zip      =  $this- zip,\n             country  =  $this- country,\n        ];\n    }\n\n    function bsonUnserialize(array $data)\n    {\n        $this- zip = $data[ zip ];\n        $this- country = $data[ country ];\n    }\n}\n\n?   Hannes is 31 years old and has two addresses;   Sunnyvale, USA  Kopavogur, Iceland   He is friends with young Jeremy, a 21 year old who lives in Michigan:  ?php\n$hannes = new Person( Hannes , 31);\n$sunnyvale = new Address(94086,  USA );\n$kopavogur = new Address(200,  Iceland );\n$hannes- addAddress($sunnyvale);\n$hannes- addAddress($kopavogur);\n\n$mikola = new Person( Jeremy , 21);\n$michigan = new Address(48169,  USA );\n$mikola- addAddress($michigan);\n\n$hannes- addFriend($mikola);\n\n?   To save this information, we can insert  $hannes  into the database like so:  ?php\ntry {\n    $wc = new MongoDB\\Driver\\WriteConcern(MongoDB\\Driver\\WriteConcern::MAJORITY);\n    $manager = new MongoDB\\Driver\\Manager( mongodb://192.168.112.10:2000 );\n    $bulk = new MongoDB\\Driver\\BulkWrite;\n    $bulk- insert($hannes);\n    $result = $manager- executeBulkWrite( congress.people , $bulk, $wc);\n    echo  Hannes has been inserted\\n ;\n} catch(Exception $e) {\n    echo $e- getMessage(),  \\n ;\n    exit;\n}\n?   This will result in the following document stored (as shown by mongo shell):  {\n   _id  : ObjectId( 551f2004bd21b959de3c15b1 ),\n   __pclass  : BinData(128, UGVyc29u ),\n   name  :  Hannes ,\n   age  : 31,\n   address  : [\n    {\n       __pclass  : BinData(128, QWRkcmVzcw== ),\n       zip  : 94086,\n       country  :  USA \n    },\n    {\n       __pclass  : BinData(128, QWRkcmVzcw== ),\n       zip  : 200,\n       country  :  Iceland \n    }\n  ],\n   friends  : [\n    {\n       __pclass  : BinData(128, UGVyc29u ),\n       _id  : ObjectId( 551f2004bd21b959de3c15b2 ),\n       name  :  Jeremy ,\n       age  : 21,\n       address  : [\n        {\n           __pclass  : BinData(128, QWRkcmVzcw== ),\n           zip  : 48169,\n           country  :  USA \n        }\n      ],\n       friends  : {\n\n      }\n    }\n  ]\n}  When we read this document back, the driver will convert the individual\nsub-documents back into their original classes, as we have full type information\nfor them now:  ?php\n\n$rp = new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_PRIMARY_PREFERRED);\n$query = new MongoDB\\Driver\\Query([]);\n$cursor = $manager- executeQuery( congress.people , $query, $rp);\n\nforeach($cursor as $person) {\n    var_dump($person);\n}\n\n?   This results in:  object(Person)#22 (6) {\n  [ _id :protected]= \n  object(BSON\\ObjectID)#15 (0) {\n  }\n  [ name :protected]= \n  string(6)  Hannes \n  [ age :protected]= \n  int(31)\n  [ address :protected]= \n  array(2) {\n    [0]= \n    object(Address)#16 (2) {\n      [ zip :protected]= \n      int(94086)\n      [ country :protected]= \n      string(3)  USA \n    }\n    [1]= \n    object(Address)#17 (2) {\n      [ zip :protected]= \n      int(200)\n      [ country :protected]= \n      string(7)  Iceland \n    }\n  }\n  [ friends :protected]= \n  array(1) {\n    [0]= \n    object(Person)#21 (6) {\n      [ _id :protected]= \n      object(BSON\\ObjectID)#18 (0) {\n      }\n      [ name :protected]= \n      string(6)  Jeremy \n      [ age :protected]= \n      int(21)\n      [ address :protected]= \n      array(1) {\n        [0]= \n        object(Address)#19 (2) {\n          [ zip :protected]= \n          int(48169)\n          [ country :protected]= \n          string(3)  USA \n        }\n      }\n      [ friends :protected]= \n      object(stdClass)#20 (0) {\n      }\n      [ secret :protected]= \n      string(4)  none \n    }\n  }\n  [ secret :protected]= \n  string(4)  none \n}", 
            "title": "Examples"
        }
    ]
}